[TOC]
### 示例 1：通过指针访问二维数组

```c
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };

    int (*p)[4] = arr;  // 定义一个指向含有4个整数的数组的指针

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", p[i][j]);  // 使用指针访问数组元素
        }
        printf("\n");
    }

    return 0;
}
```

在这个例子中，`p`是一个指向包含4个整数的一维数组的指针，因此我们可以用`p[i][j]`的方式访问二维数组的元素。

### 示例 2：使用指针算法访问二维数组

```c
#include <stdio.h>

int main() {
    int arr[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };

    int *p = &arr[0][0];  // 获取到二维数组的首地址

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%d ", *(p + i * 4 + j));  // 使用指针偏移访问元素
        }
        printf("\n");
    }

    return 0;
}
```

在这里，我们将`arr[0][0]`的地址赋给指针`p`，并使用指针偏移`*(p + i * 4 + j)`来访问元素。这种方式将二维数组“线性化”了。



## `const string &filename` 可不可以是 `const string *filename`？
### 区别总结：

1. **语法上的不同**：
   - `const string &filename` 是引用，表示不能为`filename`指向一个新的对象。
   - `const string *filename` 是指针，可以指向其他地址，但不能通过`filename`修改字符串内容。
2. **使用场景**：
   - **引用** (`const string &filename`)：
     - 主要用于不希望复制大对象的情况，如传递大字符串。
     - 引用语法较简洁，调用时无需显式解引用，访问更方便。
     - 通常适合传递对象时使用，不需要检查是否为空。
   - **指针** (`const string *filename`)：
     - 当需要传递一个可能为空的参数时可以使用指针。调用者可以传递`nullptr`来表示没有提供字符串。
     - 使用时要检查是否为空，例如`if (filename != nullptr)`。

### 示例代码：

#### 使用引用：

```c++
void openFile(const string &filename) {
    // 不需要检查是否为空 而且可以直接 openFile("D://path");
    cout << "Opening file: " << filename << endl;
}
```

#### 使用指针：

```c++
void openFile(const string *filename) {
    if (filename) { // 需要检查是否为空 而且不能直接 openFile("D://path");
        cout << "Opening file: " << *filename << endl;
    } else {
        cout << "No file specified." << endl;
    }
}
```

### 总结

- 如果函数内不需要处理空指针，可以优先使用`const string &filename`，它的语法更简单。
- 如果参数有可能为空（即调用时没有提供有效的字符串），则可以使用`const string *filename`。



## `string &param`<br> `const string param`<br> `const string &param` <br>`const string *param`<br> `string *param`<br>区别

### 1. 加不加 `&` 的效果

- **加上 `&`**：`const string &param` 表示传入的 `param` 是一个引用（即指向调用处提供的对象的地址）。这样可以避免拷贝整个字符串对象，提高效率，尤其在大型字符串传递时。
**而且加上 `&` 之后，不能再有 `param = (string) a` 的操作！**

  

- **不加 `&`**：如果改成 `const string param`，则 `param` 是按值传递的，这会**产生一个新的字符串对象（即对原字符串进行拷贝）**，但函数的输出结果还是一样的。

  这里的返回结果不变是因为 `param` 的值在函数内部没有改变，且传递的字符串内容相同。不加 `&` 会产生一次拷贝，而加上 `&` 则 **避免了这种拷贝操作，使函数更加`高效`**。
  **而且可以有`param = (string) a` 的操作**

  

### 2. 引用 `&` 和指针 `*` 的区别

- **引用 `&`**：一种别名，必须在定义时绑定到一个已有对象。引用在语法上更简洁，并且一旦绑定，不能更改指向的对象。
- **指针 `*`**：可以是空值（即 `nullptr`），可以在运行时重新指向不同的对象。需要通过解引用符号（`*`）来访问指向的值。

>**引用 `&` 和指针 `*` 的优缺点**
>
>| 特性             | 引用 `&`                         | 指针 `*`                        |
>| ---------------- | -------------------------------- | -------------------------------- |
>| **是否允许空值** | 不允许引用为空值，必须绑定到对象 | 可以为空值（`nullptr`）          |
>| **语法简洁性**   | 语法简洁，使用方式更直观         | 使用时需要解引用                 |
>| **灵活性**       | 一旦绑定不能更改                 | 可以在运行时重新指向不同的对象   |
>| **适用场景**     | 常用于传递对象的别名或不可变参数 | 常用于动态分配、条件性传递参数等 |

### 3.加不加 `const` 的效果

- **加上 `const`**：表示常量，无法被**改变**，无法被**复制**，如 `func("a string")` 中 `a string` 即为一个字符串常量
  - 字符串字面值（常量字符串）通常存储在程序的 **只读数据段（或称“文字常量区”）**。这个段被设计为只读的，防止字符串字面值在程序运行时被修改。
  - 在大多数操作系统和编译器中，常量会在**加载程序时**分配到一个**静态内存区域**，这个区域在程序运行期间**不会被释放或改变**。
  - 不同的编译器和操作系统可能有所差异，但通常都会为常量字符串分配一个固定地址。

- **不加 `const`**：
