[TOC]

### 1. 值传递（Pass by Value）

在值传递中，函数接收到的是参数的**副本**，因此**对参数的修改不会影响原变量**。

**示例**：

```c
#include <stdio.h>

void changeValue(int x) {
    x = 10;  // 修改的是 x 的副本，不影响原变量
}

int main() {
    int a = 5;
    changeValue(a);  // 传递 a 的值
    printf("a = %d\n", a);  // 输出 a = 5
    return 0;
}
```

在这个示例中，`a` 的值被传递到 `changeValue` 函数，但 `changeValue` 中的 `x` 是 `a` 的副本。即使在函数内部将 `x` 修改为 `10`，但这不会影响 `a` 的值，因此输出结果仍为 `5`。

### 2. 引用传递（Pass by Reference）

C 语言中没有直接的“引用”概念，但可以使用**指针**来实现引用传递。引用传递的本质是**将变量的地址传递给函数**，这样函数可以通过地址直接修改原变量的值。

**示例**：

```c
#include <stdio.h>

void changeValue(int *x) {
    *x = 10;  // 通过指针修改原变量的值
}

int main() {
    int a = 5;
    changeValue(&a);  // 传递 a 的地址
    printf("a = %d\n", a);  // 输出 a = 10
    return 0;
}
```

在这个示例中，`changeValue` 函数接收一个指向 `int` 的指针 `x`，并通过 `*x` 修改 `a` 的值。当我们调用 `changeValue(&a)` 时，将 `a` 的地址传递给 `x`，因此可以直接修改 `a` 的值，最终输出结果为 `10`。

### 值传递和引用传递的对比

| 传递方式 | 特点                           | 优点                         | 缺点                     |
| -------- | ------------------------------ | ---------------------------- | ------------------------ |
| 值传递   | 传递变量的副本                 | 原变量不会被修改             | 占用额外内存             |
| 引用传递 | 传递变量的地址（通过指针实现） | 可以直接修改原变量，节省内存 | 可能会意外修改原变量的值 |